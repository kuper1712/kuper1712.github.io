[ { "title": "BOJ 3495 아스키 도형", "url": "/posts/boj-3495/", "categories": "알고리즘", "tags": "Algorithm", "date": "2022-03-03 00:00:00 +0000", "snippet": "BOJ 문제 풀이문제 (link)창영이는 메모장에 ., \\, /을 이용해서 도형을 그렸다.각 문자는 그림에서 1*1크기의 단위 정사각형을 나타낸다..은 빈 칸을 나타내며, /는 정사각형의 왼쪽 아래 꼭짓점과 오른쪽 위 꼭짓점이 연결된 선분을, \\은 왼쪽 위 꼭짓점과 오른쪽 아래 꼭짓점이 연결된 선분을 나타낸다.창영이가 그린 도형의 넓이를 출력하는 프로...", "content": "BOJ 문제 풀이문제 (link)창영이는 메모장에 ., \\, /을 이용해서 도형을 그렸다.각 문자는 그림에서 1*1크기의 단위 정사각형을 나타낸다..은 빈 칸을 나타내며, /는 정사각형의 왼쪽 아래 꼭짓점과 오른쪽 위 꼭짓점이 연결된 선분을, \\은 왼쪽 위 꼭짓점과 오른쪽 아래 꼭짓점이 연결된 선분을 나타낸다.창영이가 그린 도형의 넓이를 출력하는 프로그램을 작성하시오.입력첫째 줄에 h와 w가 주어진다.h는 그림의 높이, w는 너비이다. (2 ≤ h,w ≤ 100)다음 h개 줄에는 창영이가 메모장에 그린 다각형이 주어진다.창영이가 그린 다각형은 1개이고, 변과 변이 서로 교차하는 경우는 없고, 자기 자신과 접하는 경우도 없다.풀이편의상 / \\ 기호를 변이라 하겠다.문제의 그림을 관찰해 보면변은 하나 당 0.5의 넓이를 가지고변 내부에 있는 .은 1의 넓이를 가진다는 사실을 알 수 있다.따라서 변 또는 변 내부에 있는 .을 만날 때마다 넓이를 증가시켜주면 된다.그러기 위해서는 .이 변 내부에 있는지 외부에 있는지를 판별해야 하는데본인은 변을 만나면 flag를 토글링 해 주고 flag가 true일 때 cnt를 증가시켜 해결하였다.자세한 사항은 코드를 보면 이해가 될 것이다. 코드 보기(Java) import java.io.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] str = br.readLine().split(\" \"); int H = Integer.parseInt(str[0]); int W = Integer.parseInt(str[1]); str = new String[H]; for(int i = 0; i &lt; H; i++) str[i] = br.readLine(); float area = 0; for(int i = 0; i &lt; H; i++) { for(int j = 0; j &lt; W; j++) { if (str[i].charAt(j) == '/' || str[i].charAt(j) == '\\\\') area += 0.5; } } boolean flag = false; int cnt = 0; for(int i = 0; i &lt; H; i++) { for(int j = 0; j &lt; W; j++) { char ch = str[i].charAt(j); if(ch == '\\\\' || ch == '/') flag = !flag; else if(flag) cnt++; } } System.out.println((int)(area + cnt)); }} 코드 보기(C++) #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int H, W; cin &gt;&gt; H &gt;&gt; W; string str[H]; for(int i = 0; i &lt; H; i++) cin &gt;&gt; str[i]; float area = 0; for(int i = 0; i &lt; H; i++) { for(int j = 0; j &lt; W; j++) { if(str[i][j] == '/' || str[i][j] == '\\\\') area += 0.5; } } bool flag = false; int cnt = 0; for(int i = 0; i &lt; H; i++) { for(int j = 0; j &lt; W; j++) { char ch = str[i][j]; if(ch == '\\\\' || ch == '/') flag = !flag; else if(flag) cnt++; } } cout &lt;&lt; (int)(area + cnt) &lt;&lt; \"\\n\"; return 0;} 코드 보기(Kotlin) fun main(args: Array&lt;String&gt;) { var str = readLine()!!.split(\" \") val H = str[0]!!.toInt() val W = str[1]!!.toInt() str = ArrayList&lt;String&gt;() for (i in 0 until H) str.add(readLine()!!) var area: Float = 0F for(i in 0 until H) { for(j in 0 until W) { if(str[i][j] == '/' || str[i][j] == '\\\\') area += 0.5F; } } var flag: Boolean = false var cnt = 0 for (i in 0 until H) { for (j in 0 until W) { val ch = str[i][j] if (ch == '\\\\' || ch == '/') flag = !flag else if (flag) cnt++ } } print((area + cnt).toInt())} 코드 보기(Python) def main(): str = input().split(' ') H = int(str[0]) W = int(str[1]) str = list() for i in range(0, H): str.append(input()) area = 0 for i in range(0, H): for j in range(0, W): if str[i][j] == '/' or str[i][j] == '\\\\': area += 0.5 flag = False cnt = 0 for i in range(0, H): for j in range(0, W): ch = str[i][j] if str[i][j] == '/' or str[i][j] == '\\\\': flag = not flag elif flag: cnt += 1 print(int(area + cnt)) if __name__ == \"__main__\": main() 코드 보기(Swift) import Foundationfunc main() { var str = (readLine()?.split(separator: \" \"))! let H = Int(str[0])! let W = Int(str[1])! var str2 = Array&lt;String&gt;() for i in 0..&lt;H { str2.append(readLine()!) } var area: Float = 0 for i in 0..&lt;H { for j in 0..&lt;W { let ch = str2[i][str2[i].index(str2[i].startIndex, offsetBy: j)] if ch == \"/\" || ch == \"\\\\\" { area += 0.5; } } } var flag: Bool = false var cnt: Float = 0 for i in 0..&lt;H { for j in 0..&lt;W { let ch = str2[i][str2[i].index(str2[i].startIndex, offsetBy: j)] if (ch == \"\\\\\" || ch == \"/\") { flag = !flag } else if (flag) { cnt += 1 } } } print(Int(area + cnt))}main() " }, { "title": "BOJ 10814 나이순 정렬", "url": "/posts/boj-10814/", "categories": "알고리즘", "tags": "Algorithm", "date": "2022-03-01 00:00:00 +0000", "snippet": "BOJ 문제 풀이문제 (link)온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.입력첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000) 둘째 줄부터 N개의 줄에는 각 회원의 나...", "content": "BOJ 문제 풀이문제 (link)온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.입력첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000) 둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.풀이회원들의 나이와 가입일을 기준으로 정렬하는 문제이다. 정렬 알고리즘은 안정 정렬 과 불안정 정렬로 나눠진다.안정 정렬(Stable Sort) : 정렬 기준이 같을 때 입력된 순서를 고려하여 정렬 불안정 정렬(Unstable Sort) : 입력된 순서를 고려하지 않고 정렬 각 정렬 알고리즘 중 대표적인 것은 다음과 같다. 안정 정렬(Stable Sort) 불안정 정렬(Unstable Sort) 삽입 정렬(Insertion Sort) 퀵 정렬(Quick Sort) 병합 정렬(Merge Sort) 선택 정렬(Selection Sort) 버블 정렬(Bubble Sort) 힙 정렬(Heap Sort) 각 언어가 사용하는 정렬 알고리즘은 다르므로 사용하는 언어에 따라 구현 방식이 다를수 있다. 각 언어별 구현은 아래에 설명해 두었다. 코드 보기(Java) import java.io.*;import java.util.*;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); ArrayList&lt;Member&gt; members = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; n; i++) { String member = br.readLine(); int age = Integer.parseInt(member.split(\" \")[0]); String name = member.split(\" \")[1]; members.add(new Member(age, name)); } Collections.sort(members); for(int i = 0; i &lt; members.size(); i++) System.out.println(members.get(i).age +\" \" +members.get(i).name); }}class Member implements Comparable&lt;Member&gt; { int age; String name; public Member(int age, String name) { this.age = age; this.name = name; } @Override public int compareTo(Member o) { if(this.age != o.age) return this.age - o.age; else return 0; }} Java Docs를 확인해 보면 자바의 Collections.sort() 함수는 안정 정렬인 팀 정렬(Tim Sort)을 사용한다. 따라서 나이가 다를 때만 비교값을 반환해주면 정렬이 완료된다. 코드 보기(C++) #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(pair&lt;int, string&gt; p1, pair&lt;int, string&gt; p2) { return p1.first &lt; p2.first;}int main(int argc, const char * argv[]) { int n; cin &gt;&gt; n; vector&lt;pair&lt;int, string&gt;&gt; members; pair&lt;int, string&gt; member; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; member.first &gt;&gt; member.second; members.push_back(member); } stable_sort(members.begin(), members.end(), cmp); for(int i = 0; i &lt; n; i++) { cout &lt;&lt; members[i].first &lt;&lt; \" \" &lt;&lt; members[i].second &lt;&lt; '\\n'; }} C++의 기본 sort() 함수는 불안정 정렬인 퀵 정렬(Quick Sort)을 사용하고 있다. 하지만 안정 정렬인 병합 정렬(Merge Sort)을 사용한 stable_sort() 함수를 따로 제공해 준다.stable_sort() 함수를 이용하여 정렬을 완료한다. 코드 보기(Kotlin) class Member { var age: Int var name: String constructor(age: Int, name:String) { this.age = age this.name = name }}fun main(args: Array&lt;String&gt;) { var N = readLine()!!.toInt() var members = ArrayList&lt;Member&gt;() for(i in 0 until N) { var str = readLine()!!.split(\" \") members.add(Member(str[0].toInt(), str[1])) } members.sortBy { it.age } for(i in 0 until N) { println(\"${members[i].age} ${members[i].name}\") }} Kotlin 문서에 의하면 어떤 정렬 알고리즘을 사용하는지는 나와있지 않지만 Kotlin의 sortBy() 함수는 안정 정렬이라고 한다. 따라서 나이 기준으로만 정렬 해 주면 정렬이 완료된다. 코드 보기(Python) def main(): n = int(input()) members = list() for i in range(n): member = input().split() age = int(member[0]) name = member[1] members.append((age, name)) members.sort(key = lambda age : age[0]) for i in members: print(i[0], i[1]) if __name__ == \"__main__\": main() Python 문서에 의하면 어떤 정렬 알고리즘을 사용하는지는 나와있지 않지만 Python의 sort() 함수는 안정 정렬이라고 한다. 따라서 나이 기준으로 정렬 해 주면 정렬이 완료된다. 코드 보기(Swift) import Foundationstruct Member { var age: Int var name: String}func main() { let n = Int(readLine()!)! var members = Array&lt;Member&gt;() for i in 0..&lt;n { var member = (readLine()?.split(separator: \" \"))! if let age: Int = Int(member[0]) { members.append(Member(age: age, name: String(member[1]))) } } members.sort { first, second in return first.age &lt; second.age } for i in 0..&lt;n { print(members[i].age, members[i].name) }}main() Swift의 sort() 함수는 팀 정렬(Tim Sort)을 이용하므로 안정 정렬이다. (Swift 5 부터 안정 정렬이라고 한다.) 따라서 나이 기준으로만 정렬 해 주면 정렬이 완료된다는 것을 알 수 있다.물론 안정 정렬을 사용하지 않는 방법도 있다. 입력된 순서대로 가중치를 주어 정렬 기준이 같으면 가중치를 기준으로 정렬 하면 된다. " }, { "title": "BOJ 1181 단어 정렬", "url": "/posts/boj-1181/", "categories": "알고리즘", "tags": "Algorithm", "date": "2021-03-05 00:00:00 +0000", "snippet": "BOJ 문제 풀이문제 (link)알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.길이가 짧은 것부터 길이가 같으면 사전 순으로입력첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다.주어지는 문...", "content": "BOJ 문제 풀이문제 (link)알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.길이가 짧은 것부터 길이가 같으면 사전 순으로입력첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다.주어지는 문자열의 길이는 50을 넘지 않는다.풀이주어진 기준대로 단어를 정렬하는 문제이다. 코드 보기(Java) import java.io.*;import java.util.*;class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); int N = Integer.parseInt(br.readLine()); for(int i = 0; i &lt; N; i++) set.add(br.readLine()); Comparator&lt;String&gt; comp = new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { if(o1.length() == o2.length()) return o1.compareTo(o2); return o1.length() - o2.length(); } }; String[] arr = set.toArray(new String[0]); Arrays.sort(arr, comp); for(int i = 0; i &lt; arr.length; i++) System.out.println(arr[i]); }} 코드 보기(C++) #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;struct Comp { bool operator() (const string&amp; s1, const string&amp; s2) const { if(s1.size() == s2.size()) return s1 &lt; s2; return s1.size() &lt; s2.size(); }};int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int N; cin &gt;&gt; N; set&lt;string, Comp&gt; sets; string tmp; for(int i = 0; i &lt; N; i++) { cin &gt;&gt; tmp; sets.insert(tmp); } for(auto s : sets) cout &lt;&lt; s &lt;&lt; \"\\n\"; return 0;} 코드 보기(Kotlin) fun main(args: Array&lt;String&gt;) { var N = readLine()!!.toInt() var sets = mutableSetOf&lt;String&gt;() for(i in 0 until N) sets.add(readLine()!!) val srtSet = sets.sortedWith(Comparator&lt;String&gt; { s1, s2 -&gt; if(s1.length == s2.length) s1.compareTo(s2) else s1.length - s2.length }) srtSet.forEach {println(it)}} 코드 보기(Python) def main(): N = int(input()) sets = set() for i in range(0, N): sets.add(input()) sets = sorted(sets, key = lambda x : (len(x), x)) for i in sets: print(i) if __name__ == \"__main__\": main() 코드 보기(Swift) import Foundationfunc main() { let N = Int(readLine()!)! var set : Set&lt;String&gt; = Set&lt;String&gt;() for i in 0..&lt;N { set.insert(readLine()!) } var res = set.sorted{(a, b) -&gt; Bool in if(a.count == b.count) { return a &lt; b } return a.count &lt; b.count } for i in res { print(i) }}main() " }, { "title": "BOJ 18870 좌표 압축", "url": "/posts/boj-18870/", "categories": "알고리즘", "tags": "Algorithm", "date": "2021-03-02 00:00:00 +0000", "snippet": "BOJ 문제 풀이문제 (link)수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자.입력첫째 줄에 N이 ...", "content": "BOJ 문제 풀이문제 (link)수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자.입력첫째 줄에 N이 주어진다. 둘째 줄에는 공백 한 칸으로 구분된 X1, X2, …, XN이 주어진다.풀이큰 좌표값을 압축하는 문제이다. 좌표 압축 기법은 데이터가 크지만 의미있는 데이터는 적은 경우에 의미 없는 데이터는 없애고 의미있는 데이터만 남기기 위해 자주 사용된다. 예시로 1000, 999, 1000, 999 라는 좌표가 있다고 가정하자. 1000을 2진법 1111101000(2)로 나타낼 수 있으므로 한 개의 데이터를 표현하기 위해 10bit가 사용된다. 하지만 이 데이터들을 1, 0, 1, 0 으로 압축한다면 같은 상관 관계를 갖지만 1bit만으로 숫자를 나타낼 수 있다. 물론 컴퓨터는 숫자를 나타내는데 보통 int라는 자료형을 사용하므로 4Byte를 사용할 수 있다. (64bit 기준) 이를 보고 “값을 압축하는 것이 의미가 없는게 아닌가?” 라는 생각을 할 수 있다. 하지만 4byte 이상의 아주 큰 값을 생각해 보자. 데이터가 10000000000, 999999999, 10000000000, 999999999일 경우에 1010는 10_0101_0100_0000_1011_1110_0100_0000_0000(2) 이므로 4Byte로 표현 할 수 없다. 이 경우에는 더 큰 자료형인 long을 사용해야 할 것이다. 하지만 좌표 압축을 하면 1, 0, 1, 0 이 되므로 1bit로 표현할 수 있게 된다. (실제로는 4Byte이다.)위의 사실들을 바탕으로 실제 프로세스를 생각해 보자. 좌표는 중복을 허용하지 않으므로(같은 좌표는 같은 값이므로) Map 또는 Dictionary에 추가하며 Rank를 부여해 준다. 이후 각 좌표에 부여된 Rank를 출력해 준다. 코드 보기(Java) import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.HashMap;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int N = Integer.parseInt(br.readLine()); int[] arr = new int[N]; String[] str = br.readLine().split(\" \"); for(int i = 0; i &lt; N; i++) arr[i] = Integer.parseInt(str[i]); int[] tmp = arr.clone(); Arrays.sort(arr); int rank = 0; for(int i = 0; i &lt; N; i++) { if(map.get(arr[i]) == null) map.put(arr[i], rank++); } StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; N; i++) sb.append(map.get(tmp[i]) +\" \"); System.out.println(sb); }} 코드 보기(C++) #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); map&lt;int, int&gt; mp; int n; cin &gt;&gt; n; int arr[n], tmp[n]; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; tmp[i] = arr[i]; } sort(arr, arr + n); int rank = 0; for(int i = 0; i &lt; n; i++) { if(mp[arr[i]] == 0) mp[arr[i]] = ++rank; } for(int i = 0; i &lt; n; i++) cout &lt;&lt; mp[tmp[i]] - 1 &lt;&lt; \" \"; return 0;} 코드 보기(Kotlin) import kotlin.collections.ArrayListfun main(args: Array&lt;String&gt;) { var N = readLine()!!.toInt() var arr = ArrayList&lt;Int&gt;() var tmp = ArrayList&lt;Int&gt;() var mp = emptyMap&lt;Int, Int&gt;().toMutableMap() var str = readLine()!!.split(\" \") for(i in 0 until N) { arr.add(str[i].toInt()) tmp.add(arr[i]) } arr.sort() var rank = 0 for(i in 0 until N) { if (mp[arr[i]] == null) { mp[arr[i]] = rank rank += 1 } } val sb = StringBuilder() for(i in 0 until N) { sb.append(\"${mp[tmp[i]]} \") } print(sb)} 코드 보기(Python) def main(): n = int(input()) arr = list() tmp = list() mp = dict() str = input().split(' ') for i in range(n): arr.append(int(str[i])) tmp.append(arr[i]) arr.sort() rank = 0 for i in range(n): if (arr[i] in mp) == False: mp[arr[i]] = rank rank += 1 for i in range(n): print(mp[tmp[i]]) if __name__ == \"__main__\": main() 코드 보기(Swift) import Foundationfunc main() { let n = Int(readLine()!)! var arr = Array&lt;Int&gt;() var tmp = Array&lt;Int&gt;() var mp = Dictionary&lt;Int, Int&gt;() var str = (readLine()?.split(separator: \" \"))! for i in 0..&lt;n { if let num: Int = Int(str[i]) { arr.append(num) tmp.append(num) } } arr.sort() var rank = 0 for i in 0..&lt;n { if mp[arr[i]] == nil { mp[arr[i]] = rank rank += 1 } } for i in 0..&lt;n { print(mp[tmp[i]]!, terminator: \" \") }}main() " }, { "title": "음성으로 TV제어하기 - 3.음성 인식", "url": "/posts/ir-remote3/", "categories": "개인프로젝트", "tags": "Projects", "date": "2020-03-04 00:00:00 +0000", "snippet": "음성으로 TV를 제어해 보자!지금까지는 음성인식 후의 신호를 만들어주는 부분을 구현했다. 이번에는 실제로 음성인식을 수행하는 부분을 만들어 볼 것이다.필자는 이 프로젝트를 진행하며 직접 음성인식 모델을 구축할지, 기존에 제작되어 있는 API를 가져다 쓸 지에 대하여 고민을 많이 했다. 음성인식 모델을 직접 구현해보니 음성데이터와 컴퓨팅 파워가 부족해서...", "content": "음성으로 TV를 제어해 보자!지금까지는 음성인식 후의 신호를 만들어주는 부분을 구현했다. 이번에는 실제로 음성인식을 수행하는 부분을 만들어 볼 것이다.필자는 이 프로젝트를 진행하며 직접 음성인식 모델을 구축할지, 기존에 제작되어 있는 API를 가져다 쓸 지에 대하여 고민을 많이 했다. 음성인식 모델을 직접 구현해보니 음성데이터와 컴퓨팅 파워가 부족해서 인식률과 학습 속도가 떨어지는 문제가 있었고, API를 이용하면 요청 건당 가격을 지불해야 하는 등의 문제가 있었다. 이런 문제들 때문에 다양한 API와 모델 학습 방법을 구글링해 본 결과 안드로이드OS의 내장 음성 인식 기능을 이용하는것이 가장 효율적이라는 결론에 이르렀다.하지만 안드로이드OS의 내장 음성인식 기능을 사용하기 위해서도 문제가 존재했는데, 당연하게도 안드로이드OS가 필요하다는 것이다. 처음에는 라즈베리 파이를 이용해서 음성인식을 구현하려고 계획 했지만 안드로이드OS때문에 라즈베리 파이 이용은 포기했다. 물론, 라즈베리 파이에도 안드로이드를 올릴 수 있겠지만, 창고를 조금만 찾아보면 이전에 사용하던 성능 짱짱한 안드로이드 폰들이 숨어있는데 굳이 라즈베리 파이에 안드로이드를 설치할 필요성을 느끼지 못했다. 심지어 안드로이드 폰에는 마이크까지 기본으로 붙어있다!필자는 창고에 숨어있던 갤럭시 노트4를 음성 인식기로 사용하기로 했다. 기기는 정해졌으므로 이전에 만들었던 H/W와 안드로이드의 음성인식 기능을 연동하기만 하면 음성으로 TV를 제어할 수 있게 된다.안드로이드에서 음성을 인식하고 UDP 패킷을 전송하기 위해 어플리케이션을 제작했다. 첨부된 앱을 다운받아 음성 인식기로 사용할 안드로이드 폰에 설치하고 실행하면 된다. 앱이 동작하는 방식은 간단하다. 안드로이드의 음성 인식 기능이 문자열로 인식된 결과를 반환해 주면 반환된 문자열을 비교해 각각 기능의 UDP 패킷을 생성하여 이전에 만들어 두었던 H/W에 전송한다.안드로이드 앱(apk) / 소스 코드어플리케이션을 설치하고 실행 해 보면 마이크 권한을 요구할텐데 음성을 인식 하기 위해서 마이크가 필요하므로 권한을 허용해 줘야 한다. 권한까지 허용해 주었다면 아래와 같이 메인 화면이 표시 된다.“Enter your IP!!!” 부분에 이전에 만들었던 ESP-01 회로의 IP주소를 입력하고 “SET!!!”버튼을 클릭하면 UDP 패킷을 전송할 IP가 설정된다. 이렇게 음성인식까지 연동을 시켰다. 마이크에 대고 “TV 꺼 줘”라고 말하면 TV가 꺼지고 “TV 켜 줘”라고 말하면 TV가 켜지는 것을 볼 수 있을 것이다. 물론 TV를 끄고 켜고 하는 기능 외에도 여러 다른 기능들도 사용할 수 있다.사용할 수 있는 기능을 표로 정리해 두었다. 명령 동작 TV 켜 줘/꺼 줘 TV 전원 On/Off 볼륨 업/음량 키워 음량 올림 볼륨 다운/음량 내려 음량 내림 채널 업/채널 올려 채널 올림 채널 다운/채널 내려 채널 내림 (숫자) 채널 (숫자)번 채널로 이동 이 기능들 말고도 “조용히” 기능이나 리모컨의 기타 다른 기능들을 추가하고 싶거나 애플리케이션의 난잡한 소스를 깔끔하게 정리해서 사용하고 싶다면 마음껏 수정해서 사용해도 좋다. 참고로 이 프로젝트는 적외선 리모컨이 대상이었으므로 TV외에도 에어컨, 공기청정기 등 적외선 리모컨을 이용하는 기기라면 어디에든 사용할 수 있다!마지막으로 필자의 어플리케이션은 안드로이드의 내장 음성인식 기능을 사용한다고 하였는데 이는 심각한 문제가 있다. 음성 인식을 시작하고 종료할 때마다 계속 알림음이 난다는 것이다. 이 부분은 아예 소리를 끄고 사용하거나 서드파티 안드로이드 음성 인식 엔진을 (Ex. Sphinx CMU) 사용하면 해결될 것 같다. 일단 동작은 잘 되므로 소리를 아예 꺼놓고 사용해 보다가 나중에 추가적으로 불편한 점이 생기거나 못 쓸정도라고 생각되면 코드 정리와 개선을 조금 해야겠다." }, { "title": "음성으로 TV제어하기 - 2.TV 제어", "url": "/posts/ir-remote2/", "categories": "개인프로젝트", "tags": "Projects", "date": "2020-03-03 00:00:00 +0000", "snippet": "음성으로 TV를 제어해 보자!이 전 글에서는 리모컨의 적외선 신호를 복제하는 방법에 대하여 다뤘다. 이번 글에서는 복제한 신호를 이용해 실제로 TV를 제어 할 수 있는 장치를 만들어 보도록 하겠다.아두이노를 이용해 외부와의 연결 없이 테스트를 할 수도 있지만, 다른 장치에서 인식된 음성으로 제어하기 위해 외부와의 연결이 필요하다. 물론 음성인식 엔진을...", "content": "음성으로 TV를 제어해 보자!이 전 글에서는 리모컨의 적외선 신호를 복제하는 방법에 대하여 다뤘다. 이번 글에서는 복제한 신호를 이용해 실제로 TV를 제어 할 수 있는 장치를 만들어 보도록 하겠다.아두이노를 이용해 외부와의 연결 없이 테스트를 할 수도 있지만, 다른 장치에서 인식된 음성으로 제어하기 위해 외부와의 연결이 필요하다. 물론 음성인식 엔진을 아두이노에 직접 올린다면 오프라인으로 음성 인식과 제어 둘 다 가능하겠지만, 성능상의 문제와 직접 음성인식 엔진을 구현해야 한다는 문제가 있다. 이 때문에 필자는 WIFI 모듈을 이용하여 외부의 음성인식 엔진과 통신을 하는 방식으로 구현 할 생각이다.ESP-01 모듈은 Espressif Systems 에서 개발한 와이파이 모듈로, 가격이 저렴하고 소형이기 때문에 와이파이 모듈 중에서는 가장 범용적이고, 상당히 많은 개발 환경을 지원한다고 한다. 겉핥기 식이긴 하지만, 직접 다른 개발 환경(Lua, Sming)을 사용해 본 결과 복잡하고 불편하다고 느꼈기 때문에 이 글에서는 비교적 간단한 아두이노 스케치를 이용할 것이다.ESP-01을 아두이노 스케치로 프로그래밍 하려면 먼저 아두이노 스케치에 보드 정보와 라이브러리를 추가 해 주어야 한다. 아두이노 IDE의 Preferences로 가서 “추가적인 보드 매니저 URLs”에 아래의 링크를 추가 해 주도록 한다.http://arduino.esp8266.com/stable/package_esp8266com_index.json그 후, 툴-보드-보드 매니저를 실행하여 검색 창에 esp를 입력하면 esp8266 보드를 찾을 수 있을 것이다. 설치하도록 하자.이렇게 하면 일단 보드에 관한 설정은 끝난 것이다. 이제 사용할 라이브러리들을 추가해 주도록 하겠다. 아두이노 IDE의 스케치-라이브러리 포함하기-라이브러리 관리를 클릭하면 라이브러리 매니저가 보일 것이다. 검색 창에 irremoteesp 라고 입력 하여 esp01에서 적외선 센서를 제어 할 수 있게 해 주는 라이브러리를 설치하자.위의 모든 작업을 마쳤으면 파일-새 파일을 클릭해 새 파일을 만들고, 내부의 모든 내용을 지우고 아래의 코드를 붙여넣기 하면 된다. 와이파이 변수 부분과 리모컨 각각 기능의 신호값은 자신의 환경에 맞게 설정하도록 하자. 코드 보기 #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt;#include &lt;IRremoteESP8266.h&gt;#include &lt;IRsend.h&gt;const char* ssid = \"자신의 WIFI ssid\";const char* password = \"자신의 WIFI 암호\";IRsend send(3);WiFiUDP Udp;unsigned int localUdpPort = 8011;char incomingPacket[255];void setup() { pinMode(3, FUNCTION_3); pinMode(3, OUTPUT); digitalWrite(3, LOW); pinMode(2, OUTPUT); digitalWrite(2, LOW); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) delay(500); Udp.begin(localUdpPort);}void tvTurn() { //전원 상태 변경 send.sendNEC(0x1FE807F, 32); send.sendNEC(0x1FEFF00, 32); send.sendNEC(0xE0E040BF, 32); send.sendNEC(0x20DF10EF, 32); send.sendNEC(0x1FE8F80, 32);}void volumeUp() { //볼륨 업 send.sendNEC(0xE0E0E01F, 32); send.sendNEC(0x20DF40BF, 32);}void volumeDown() { //볼륨 다운 send.sendNEC(0xE0E0D02F, 32); send.sendNEC(0x20DFC03F, 32);}void channelUp() { //채널 업 send.sendNEC(0x1FE02FD, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void channelDown() { //채널 다운 send.sendNEC(0x1FE827D, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void zero() { //0 send.sendNEC(0x1FE04FB, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void one() { //1 send.sendNEC(0x1FE847B, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void two() { //2 send.sendNEC(0x1FE44BB, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void three() { //3 send.sendNEC(0x1FEC43B, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void four() { //4 send.sendNEC(0x1FE24DB, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void five() { //5 send.sendNEC(0x1FEA45B, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void six() { //6 send.sendNEC(0x1FE649B, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void seven() { //7 send.sendNEC(0x1FEE41B, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void eight() { //8 send.sendNEC(0x1FE14EB, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void nine() { //9 send.sendNEC(0x1FE946B, 32); send.sendNEC(0xFFFFFFFF, 32); send.sendNEC(0x1FEFF00, 32);}void loop(){ int packetSize = Udp.parsePacket(); if (packetSize) { int len = Udp.read(incomingPacket, 255); if (len &gt; 0) incomingPacket[len] = 0; if (strcmp(\"trn\", incomingPacket) == 0) tvTurn(); else if (strcmp(\"cUp\", incomingPacket) == 0) channelUp(); else if (strcmp(\"cDn\", incomingPacket) == 0) channelDown(); else if (strcmp(\"vUp\", incomingPacket) == 0) volumeUp(); else if (strcmp(\"vDn\", incomingPacket) == 0) volumeDown(); else if (strcmp(\"0\", incomingPacket) == 0) zero(); else if (strcmp(\"1\", incomingPacket) == 0) one(); else if (strcmp(\"2\", incomingPacket) == 0) two(); else if (strcmp(\"3\", incomingPacket) == 0) three(); else if (strcmp(\"4\", incomingPacket) == 0) four(); else if (strcmp(\"5\", incomingPacket) == 0) five(); else if (strcmp(\"6\", incomingPacket) == 0) six(); else if (strcmp(\"7\", incomingPacket) == 0) seven(); else if (strcmp(\"8\", incomingPacket) == 0) eight(); else if (strcmp(\"9\", incomingPacket) == 0) nine(); }} 위의 코드를 보드에 업로드 하기 위해서 회로를 구성해야 한다. 하지만 ESP-01모듈에는 펌웨어를 업로드할수 있는 프로그래머가 없기 때문에 FTDI라는 외장 프로그래머를 사용해야 한다. 아래 그림에서 빨간 부품이 FTDI이고 파란 부품이 ESP-01이다.회로 구성을 완료 한 후 아두이노 IDE의 툴-보드를 Generic ESP8266 Module로 설정하고 컴파일/업로드를 한다. 업로드 중에 보드에 연결중이라는 메세지가 나오면 ESP-01의 CH_PD핀을 뽑았다가 다시 꽂아준다. ESP-01의 CH_PD핀은 MCU의 활성 상태를 나타내는데, High이면 활성 Low이면 비활성 상태이다. 핀을 뽑았다가 다시 꽂아주는 행위는 esp8266칩(MCU)을 재부팅 시킨다 라고 이해하면 되겠다.이렇게 보드에 업로드작업까지 완료했다. 이제 펌웨어가 구워진 보드를 가지고 실제로 TV를 제어할 수 있도록 플래싱용 회로를 실행용 회로로 다시 꾸며야 한다. 아래의 그림과 같이 적외선 LED를 포함하여 회로를 재구성하도록 하자.마지막으로 완성된 회로가 잘 동작하는지 확인하기 위해 직접 UDP로 신호를 보내보겠다. UDP신호를 생성하기 위해 여기의 프로그램(PacketSender)을 다운로드/설치 실행 한다.그럼 위와 같은 창이 열릴텐데 ASCII 부분에는 전송하고싶은 메세지 (여기에서는 TV를 켜거나 끄라는 의미로 trn을 넣었다), Address는 ESP-01의 ip주소, Port는 8011로 설정한 뒤 TCP라고 써있는 부분을 클릭해 UDP로 변경해 주도록 한다. 그리고 Send버튼을 클릭하면 ESP-01로 TV를 켜라는 메세지가 가게 된다.TV앞에 두고 UDP신호를 전송하여 잘 동작이 되는지 테스트 하면 된다. 만일 TV앞에 가는것이 귀찮거나 불가능하다면 휴대폰의 카메라를 통해 적외선 LED를 보면 적외선 LED가 깜빡이는지 확인 할 수 있다. 휴대폰 카메라를 이용한 확인은 적외선 신호가 잘 나오는지 아닌지에 대해서만 확인 가능하며, 신호가 잘 나온다 하더라도 잡음이나 신호 캡쳐의 문제 등 다른 이유에 의해 TV의 전원은 on/off되지 않을 수 있다.이번에는 udp 패킷을 수동으로 생성하여 신호를 전송하는 방식으로 구현했으므로 다음 글에서는 특정 음성이 인식되면 자동으로 udp 패킷을 생성하여 신호를 전송하도록 해 보겠다." }, { "title": "음성으로 TV제어하기 - 1.신호 복제", "url": "/posts/ir-remote1/", "categories": "개인프로젝트", "tags": "Projects", "date": "2020-03-02 00:00:00 +0000", "snippet": "음성으로 TV를 제어해 보자!여가 생활을 즐기기 위해 TV를 보려 하면 리모컨이 저 멀리 있거나, 어디 있는지 모를 때가 많다. 그럴 때마다 한번 쯤은 리모컨 없이 기계를 제어하는 상상을 해 보았을 것이다. 물론 현재 시중에는 더욱 쉽고 다양한 방법으로 제어 할 수 있도록 개발된 제품이 많이 출시되어 있지만 이를 위해 새 TV를 사거나 AI 스피커를 ...", "content": "음성으로 TV를 제어해 보자!여가 생활을 즐기기 위해 TV를 보려 하면 리모컨이 저 멀리 있거나, 어디 있는지 모를 때가 많다. 그럴 때마다 한번 쯤은 리모컨 없이 기계를 제어하는 상상을 해 보았을 것이다. 물론 현재 시중에는 더욱 쉽고 다양한 방법으로 제어 할 수 있도록 개발된 제품이 많이 출시되어 있지만 이를 위해 새 TV를 사거나 AI 스피커를 구매하는 것은 비효율 적이라는 생각이 들었다. 그래서 간단하게나마 직접 개발해 보기로 하였다.가장 처음 해야 할 일은 TV에 자동으로 신호를 전송하는 부분을 설계하는 일이다. 리모컨에 직접 모터와 각종 장치들을 달아 제어하는 방법도 있지만, 이 방식은 많은 문제가 존재하므로 적외선 수신기로 리모컨의 적외선 신호를 그대로 복제하여 저장해 두었다가 신호를 보내고 싶을 때 발신기로 적외선 신호를 전송하는 방식을 사용하기로 하였다. 쉽게 말해, 리모컨을 복제해 두었다가 특정 음성이 인식되면 신호를 직접 생성해서 전송하는 장치를 만든다는 것이다.Hardware그러기 위해서는 먼저 리모컨의 신호를 복제해 두어야 하는데, 간단히 아두이노 나노와 적외선 수신 센서를 이용해 리모컨의 적외선 신호를 복제해 보겠다. 필자가 사용한 적외선 센서는 TSOP1738이고, 이 센서의 PINOUT은 아래의 이미지와 같다. TSOP1738이 동작하기 위해서는 5V의 전압이 필요하다. 그러므로 아두이노의 5V핀과 TSOP의 Vs부분을 연결 시켜주도록 하자. 또한, 아두이노에서 TSOP의 데이터를 읽어오기 위해 OUT핀과 아두이노의 D11핀도 연결한다. (굳이 D11핀에 연결하는 이유는 아래에 나온다) 아래의 이미지처럼 회로를 구성하면 된다. Software하드웨어의 구성이 끝났으므로 소프트웨어를 만들어 보겠다. IRremote 라이브러리에 포함된 예제인 IRrecvDumpV2를 이용하도록 하겠다. IRremote 라이브러리는 아두이노에 기본적으로 포함되어있는 라이브러리가 아니므로 먼저 IRremote 라이브러리를 추가해야 한다.아두이노 IDE의 스케치-&gt;라이브러리 포함하기-&gt;라이브러리 관리로 들어가면 라이브러리 매니저 창이 뜰것이다. IRremote를 검색하여 설치 해 주도록 하자. 라이브러리 설치를 완료했으면 아두이노 IDE의 파일-&gt;예제-&gt;IRremote-&gt;IRrecvDumpV2를 열어준다. 아래와 같은 코드가 로딩된다면 잘 설치된 것이다.위에서 Data핀을 아두이노의 D11핀에 연결하라고 하였다. 그 이유가 여기에 있는데, 코드의 9번째 줄을 보면int recvPin = 11;와 같이 초기화 된 것을 알 수 있다. 이는 데이터를 받을 핀을 지정해 준 것인데, 간단히 데이터를 확인만 할 것이므로 코드를 수정할 필요가 없게 하기위해 D11핀에 연결한 것이다. D11핀이 아닌 다른 핀으로 변경해 주어도 문제는 없다.회로 구성과 코드 편집이 완료 되었다면 아두이노를 컴퓨터에 연결하여 프로그램을 컴파일/업로드 한다.업로드가 성공적으로 완료되었다면 툴-&gt;시리얼 모니터를 실행하고 적외선 센서를 향해 리모컨 버튼을 눌러 신호를 읽어본다. 필자는 SK BTV를 사용하므로 아래와 같은 신호를 얻을 수 있었다. 기능 신호 전원 1FE807F 1FEFF00 E0E040BF 20DF10EF 1FE8F80 볼륨up E0E0E01F 20DF40BF 볼륨down E0E0D02F 20DFC03F 채널up 1FE02FD FFFFFFFF 1FEFF00 채널down 1FE827D FFFFFFFF 1FEFF00 숫자 0 1FE04FB FFFFFFFF 1FEFF00 숫자 1 1FE847B FFFFFFFF 1FEFF00 숫자 2 1FE44BB FFFFFFFF 1FEFF00 숫자 3 1FEC43B FFFFFFFF 1FEFF00 숫자 4 1FE24DB FFFFFFFF 1FEFF00 숫자 5 1FEA45B FFFFFFFF 1FEFF00 숫자 6 1FE649B FFFFFFFF 1FEFF00 숫자 7 1FEE41B FFFFFFFF 1FEFF00 숫자 8 1FE14EB FFFFFFFF 1FEFF00 숫자 9 1FE946B FFFFFFFF 1FEFF00 신호를 얻을 때 주의할 점이 있는데 대상 리모컨의 적외선이 아닌 태양 적외선, 다른 장치의 적외선 등 잡음이 섞일 수 있으니 여러번 측정하여 가장 최적화 된 값을 읽어야 한다는 점이다. 필자는 5번 정도 측정해 보았다.또한, 실제로 읽히는 신호는 필자의 리모컨 신호와는 다를 수도 있다. TV의 종류와 리모컨의 종류에 따라 신호 형식이 달라질 수 있으므로 자신의 리모컨에 맞는 신호를 얻어야 한다.다음 글에서는 얻은 신호를 이용해 실제로 리모컨 없이 TV를 제어하는 방법에 대해 글을 쓰도록 하겠다. 얻은 신호는 한 곳에 잘 저장해 두도록 하자." } ]
